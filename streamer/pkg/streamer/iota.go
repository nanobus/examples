// Code generated by @apexlang/codegen. DO NOT EDIT.

package streamer

import (
	"context"
	"encoding/binary"

	"github.com/google/uuid"
	"github.com/nanobus/iota/go/invoke"
	"github.com/nanobus/iota/go/msgpack"
	"github.com/nanobus/iota/go/msgpack/convert"
	"github.com/nanobus/iota/go/payload"
	"github.com/nanobus/iota/go/proxy"
	"github.com/nanobus/iota/go/rx/flux"
	"github.com/nanobus/iota/go/rx/mono"
	"github.com/nanobus/iota/go/transform"
)

func (o *Customer) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "id":
			o.ID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		case "firstName":
			o.FirstName, err = decoder.ReadString()
		case "lastName":
			o.LastName, err = decoder.ReadString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Customer) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(3)
	encoder.WriteString("id")
	encoder.WriteString(o.ID.String())
	encoder.WriteString("firstName")
	encoder.WriteString(o.FirstName)
	encoder.WriteString("lastName")
	encoder.WriteString(o.LastName)

	return nil
}

func RegisterStreamer(svc Streamer) {
	invoke.ExportRequestResponse("streamer.v1.Streamer", "process", streamerProcessWrapper(svc))
}

func streamerProcessWrapper(svc Streamer) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		response := svc.Process(ctx)
		return mono.Map(response, transform.Void.Encode)
	}
}

var (
	gCaller invoke.Caller
)

func Initialize(caller invoke.Caller) {
	gCaller = caller
}

type SourceImpl struct {
	opRead uint32
}

func NewSource() *SourceImpl {
	return &SourceImpl{
		opRead: invoke.ImportRequestStream("streamer.v1.Source", "read"),
	}
}

func (s *SourceImpl) Read(ctx context.Context) flux.Flux[Customer] {
	payloadData := []byte{}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], s.opRead)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestStream(ctx, pl)
	return flux.Map(future, transform.MsgPackDecode[Customer])
}

type SinkImpl struct {
	opWrite uint32
}

func NewSink() *SinkImpl {
	return &SinkImpl{
		opWrite: invoke.ImportRequestChannel("streamer.v1.Sink", "write"),
	}
}

func (s *SinkImpl) Write(ctx context.Context, out flux.Flux[Customer]) mono.Void {
	payloadData := []byte{}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], s.opWrite)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestChannel(ctx, pl, flux.Map(out, transform.MsgPackEncode[Customer]))
	return transform.FluxToVoid(future)
}
