// Code generated by @apexlang/codegen. DO NOT EDIT.

package sample

import (
	"context"
	"encoding/binary"

	"github.com/nanobus/iota/go/invoke"
	"github.com/nanobus/iota/go/msgpack"
	"github.com/nanobus/iota/go/payload"
	"github.com/nanobus/iota/go/proxy"
	"github.com/nanobus/iota/go/rx/mono"
	"github.com/nanobus/iota/go/transform"
)

type TestReverseArgs struct {
	Input string `json:"input" yaml:"input" msgpack:"input"`
}

func (o *TestReverseArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "input":
			o.Input, err = decoder.ReadString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *TestReverseArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("input")
	encoder.WriteString(o.Input)

	return nil
}

type ExternalUppercaseArgs struct {
	Input string `json:"input" yaml:"input" msgpack:"input"`
}

func (o *ExternalUppercaseArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "input":
			o.Input, err = decoder.ReadString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *ExternalUppercaseArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("input")
	encoder.WriteString(o.Input)

	return nil
}

func RegisterTest(svc Test) {
	invoke.ExportRequestResponse("suite.Test", "op", testOpWrapper(svc))
	invoke.ExportRequestResponse("suite.Test", "reverse", testReverseWrapper(svc))
}

func testOpWrapper(svc Test) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		response := svc.Op(ctx)
		return mono.Map(response, transform.String.Encode)
	}
}

func testReverseWrapper(svc Test) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		var inputArgs TestReverseArgs
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.Reverse(ctx, inputArgs.Input)
		return mono.Map(response, transform.String.Encode)
	}
}

var (
	gCaller invoke.Caller
)

func Initialize(caller invoke.Caller) {
	gCaller = caller
}

type ExternalImpl struct {
	opUppercase uint32
}

func NewExternal() *ExternalImpl {
	return &ExternalImpl{
		opUppercase: invoke.ImportRequestResponse("suite.External", "uppercase"),
	}
}

func (e *ExternalImpl) Uppercase(ctx context.Context, input string) mono.Mono[string] {
	request := ExternalUppercaseArgs{
		Input: input,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[string](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], e.opUppercase)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.String.Decode)
}
