// Code generated by @apexlang/codegen. DO NOT EDIT.

package urlshortener

import (
	"context"
	"encoding/binary"

	"github.com/nanobus/iota/go/invoke"
	"github.com/nanobus/iota/go/msgpack"
	"github.com/nanobus/iota/go/payload"
	"github.com/nanobus/iota/go/proxy"
	"github.com/nanobus/iota/go/rx/mono"
	"github.com/nanobus/iota/go/transform"
)

var (
	gCaller invoke.Caller
)

func Initialize(caller invoke.Caller) {
	gCaller = caller
}

type RepositoryImpl struct {
	opLoadByID  uint32
	opLoadByURL uint32
	opStoreURL  uint32
}

func NewRepository() *RepositoryImpl {
	return &RepositoryImpl{
		opLoadByID:  invoke.ImportRequestResponse("urlshortener.v1.Repository", "loadById"),
		opLoadByURL: invoke.ImportRequestResponse("urlshortener.v1.Repository", "loadByURL"),
		opStoreURL:  invoke.ImportRequestResponse("urlshortener.v1.Repository", "storeURL"),
	}
}

func (r *RepositoryImpl) LoadByID(ctx context.Context, id string) mono.Mono[URL] {
	request := RepositoryLoadByIdArgs{
		ID: id,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[URL](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.opLoadByID)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.MsgPackDecode[URL])
}

func (r *RepositoryImpl) LoadByURL(ctx context.Context, url string) mono.Mono[URL] {
	request := RepositoryLoadByURLArgs{
		URL: url,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[URL](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.opLoadByURL)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.MsgPackDecode[URL])
}

func (r *RepositoryImpl) StoreURL(ctx context.Context, url *URL) mono.Void {
	payloadData, err := msgpack.ToBytes(url)
	if err != nil {
		return mono.Error[struct{}](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.opStoreURL)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Void.Decode)
}
