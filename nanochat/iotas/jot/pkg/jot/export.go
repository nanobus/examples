// Code generated by @apexlang/codegen. DO NOT EDIT.

package jot

import (
	"context"

	"github.com/nanobus/iota/go/wasmrs/invoke"
	"github.com/nanobus/iota/go/wasmrs/payload"
	"github.com/nanobus/iota/go/wasmrs/rx/mono"
	"github.com/nanobus/iota/go/wasmrs/transform"
)

func RegisterJots(svc Jots) {
	invoke.ExportRequestResponse("nanochat.io.v1.jots.Jots", "postJot", jotsPostJotWrapper(svc))
	invoke.ExportRequestResponse("nanochat.io.v1.jots.Jots", "getFeed", jotsGetFeedWrapper(svc))
	invoke.ExportRequestResponse("nanochat.io.v1.jots.Jots", "getJot", jotsGetJotWrapper(svc))
	invoke.ExportRequestResponse("nanochat.io.v1.jots.Jots", "deleteJot", jotsDeleteJotWrapper(svc))
	invoke.ExportRequestResponse("nanochat.io.v1.jots.Jots", "like", jotsLikeWrapper(svc))
	invoke.ExportRequestResponse("nanochat.io.v1.jots.Jots", "unlike", jotsUnlikeWrapper(svc))
	invoke.ExportRequestResponse("nanochat.io.v1.jots.Jots", "likes", jotsLikesWrapper(svc))
}

func RegisterUsers(svc Users) {
	invoke.ExportRequestResponse("nanochat.io.v1.jots.Users", "getProfile", usersGetProfileWrapper(svc))
	invoke.ExportRequestResponse("nanochat.io.v1.jots.Users", "getJots", usersGetJotsWrapper(svc))
	invoke.ExportRequestResponse("nanochat.io.v1.jots.Users", "follow", usersFollowWrapper(svc))
	invoke.ExportRequestResponse("nanochat.io.v1.jots.Users", "unfollow", usersUnfollowWrapper(svc))
	invoke.ExportRequestResponse("nanochat.io.v1.jots.Users", "getFollows", usersGetFollowsWrapper(svc))
	invoke.ExportRequestResponse("nanochat.io.v1.jots.Users", "getFollowers", usersGetFollowersWrapper(svc))
}

func jotsPostJotWrapper(svc Jots) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		var inputArgs JotsPostJotArgs
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.PostJot(ctx, inputArgs.Message)
		return mono.Map(response, transform.MsgPackEncode[Jot])
	}
}

func jotsGetFeedWrapper(svc Jots) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		var inputArgs JotsGetFeedArgs
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.GetFeed(ctx, inputArgs.Before, inputArgs.Limit)
		return mono.Map(response, transform.MsgPackEncode[JotPage])
	}
}

func jotsGetJotWrapper(svc Jots) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		var inputArgs JotsGetJotArgs
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.GetJot(ctx, inputArgs.ID)
		return mono.Map(response, transform.MsgPackEncode[Jot])
	}
}

func jotsDeleteJotWrapper(svc Jots) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		var inputArgs JotsDeleteJotArgs
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.DeleteJot(ctx, inputArgs.ID)
		return mono.Map(response, transform.MsgPackEncode[Jot])
	}
}

func jotsLikeWrapper(svc Jots) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		var inputArgs JotsLikeArgs
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.Like(ctx, inputArgs.ID)
		return mono.Map(response, transform.Void.Encode)
	}
}

func jotsUnlikeWrapper(svc Jots) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		var inputArgs JotsUnlikeArgs
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.Unlike(ctx, inputArgs.ID)
		return mono.Map(response, transform.Void.Encode)
	}
}

func jotsLikesWrapper(svc Jots) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		var inputArgs JotsLikesArgs
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.Likes(ctx, inputArgs.ID, &inputArgs.Pagination)
		return mono.Map(response, transform.MsgPackEncode[UserPage])
	}
}

func usersGetProfileWrapper(svc Users) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		var inputArgs UsersGetProfileArgs
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.GetProfile(ctx, inputArgs.Handle)
		return mono.Map(response, transform.MsgPackEncode[User])
	}
}

func usersGetJotsWrapper(svc Users) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		var inputArgs UsersGetJotsArgs
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.GetJots(ctx, inputArgs.Handle, inputArgs.Before, inputArgs.Limit)
		return mono.Map(response, transform.MsgPackEncode[JotPage])
	}
}

func usersFollowWrapper(svc Users) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		var inputArgs UsersFollowArgs
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.Follow(ctx, inputArgs.Handle)
		return mono.Map(response, transform.Void.Encode)
	}
}

func usersUnfollowWrapper(svc Users) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		var inputArgs UsersUnfollowArgs
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.Unfollow(ctx, inputArgs.Handle)
		return mono.Map(response, transform.Void.Encode)
	}
}

func usersGetFollowsWrapper(svc Users) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		var inputArgs UsersGetFollowsArgs
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.GetFollows(ctx, inputArgs.Handle, &inputArgs.Pagination)
		return mono.Map(response, transform.MsgPackEncode[UserPage])
	}
}

func usersGetFollowersWrapper(svc Users) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		var inputArgs UsersGetFollowersArgs
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.GetFollowers(ctx, inputArgs.Handle, &inputArgs.Pagination)
		return mono.Map(response, transform.MsgPackEncode[UserPage])
	}
}
