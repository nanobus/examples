// Code generated by @apexlang/codegen. DO NOT EDIT.

package follow

import (
	"context"
	"encoding/binary"
	"time"

	"github.com/google/uuid"
	"github.com/nanobus/iota/go/invoke"
	"github.com/nanobus/iota/go/msgpack"
	"github.com/nanobus/iota/go/msgpack/convert"
	"github.com/nanobus/iota/go/payload"
	"github.com/nanobus/iota/go/proxy"
	"github.com/nanobus/iota/go/rx/flux"
	"github.com/nanobus/iota/go/rx/mono"
	"github.com/nanobus/iota/go/transform"
)

type ns struct{}

func (n *ns) Namespace() string {
	return "nanochat.io.follows.v1"
}

type FollowStore interface {
	Load(ctx context.Context, userID uuid.UUID) mono.Mono[UserRef]
	GetMultiple(ctx context.Context, userIDs []uuid.UUID) flux.Flux[UserRef]
	IsFollowing(ctx context.Context, userID uuid.UUID) mono.Mono[bool]
	Follow(ctx context.Context, followedID uuid.UUID) mono.Void
	Unfollow(ctx context.Context, followedID uuid.UUID) mono.Void
	FetchFollowers(ctx context.Context, userID uuid.UUID, offset uint32, limit uint32) flux.Flux[FollowRef]
	FetchFollows(ctx context.Context, userID uuid.UUID, offset uint32, limit uint32) flux.Flux[FollowRef]
	MyFollows(ctx context.Context) flux.Flux[FollowRef]
}

type FollowRef struct {
	ns
	// User ID.
	ID uuid.UUID `json:"id" yaml:"id" msgpack:"id"`
	// Creation timestamp (for sorting)
	Time time.Time `json:"time" yaml:"time" msgpack:"time"`
}

func (f *FollowRef) Type() string {
	return "FollowRef"
}

// User record
type UserRef struct {
	ns
	// User ID.
	ID uuid.UUID `json:"id" yaml:"id" msgpack:"id"`
	// The number of followers
	Followers uint32 `json:"followers" yaml:"followers" msgpack:"followers"`
	// The number of users followed
	Follows uint32 `json:"follows" yaml:"follows" msgpack:"follows"`
}

func (u *UserRef) Type() string {
	return "UserRef"
}

// Follow record
type Follow struct {
	ns
	// The ID of the user being followed
	FollowedID uuid.UUID `json:"followedId" yaml:"followedId" msgpack:"followedId"`
	// The follower's user ID
	FollowerID uuid.UUID `json:"followerId" yaml:"followerId" msgpack:"followerId"`
	// Creation timestamp (for sorting)
	Time time.Time `json:"time" yaml:"time" msgpack:"time"`
}

func (f *Follow) Type() string {
	return "Follow"
}

type FollowStoreLoadArgs struct {
	UserID uuid.UUID `json:"userId" yaml:"userId" msgpack:"userId"`
}

func (o *FollowStoreLoadArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "userId":
			o.UserID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *FollowStoreLoadArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("userId")
	encoder.WriteString(o.UserID.String())

	return nil
}

type FollowStoreGetMultipleArgs struct {
	UserIDs []uuid.UUID `json:"userIds" yaml:"userIds" msgpack:"userIds"`
}

func (o *FollowStoreGetMultipleArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "userIds":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.UserIDs = make([]uuid.UUID, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem uuid.UUID
				nonNilItem, err = convert.Parse(uuid.Parse)(decoder.ReadString())
				if err != nil {
					return err
				}
				o.UserIDs = append(o.UserIDs, nonNilItem)
			}
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *FollowStoreGetMultipleArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("userIds")
	encoder.WriteArraySize(uint32(len(o.UserIDs)))
	for _, v := range o.UserIDs {
		encoder.WriteString(v.String())
	}

	return nil
}

type FollowStoreIsFollowingArgs struct {
	UserID uuid.UUID `json:"userId" yaml:"userId" msgpack:"userId"`
}

func (o *FollowStoreIsFollowingArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "userId":
			o.UserID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *FollowStoreIsFollowingArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("userId")
	encoder.WriteString(o.UserID.String())

	return nil
}

type FollowStoreFollowArgs struct {
	FollowedID uuid.UUID `json:"followedId" yaml:"followedId" msgpack:"followedId"`
}

func (o *FollowStoreFollowArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "followedId":
			o.FollowedID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *FollowStoreFollowArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("followedId")
	encoder.WriteString(o.FollowedID.String())

	return nil
}

type FollowStoreUnfollowArgs struct {
	FollowedID uuid.UUID `json:"followedId" yaml:"followedId" msgpack:"followedId"`
}

func (o *FollowStoreUnfollowArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "followedId":
			o.FollowedID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *FollowStoreUnfollowArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("followedId")
	encoder.WriteString(o.FollowedID.String())

	return nil
}

type FollowStoreFetchFollowersArgs struct {
	UserID uuid.UUID `json:"userId" yaml:"userId" msgpack:"userId"`
	Offset uint32    `json:"offset" yaml:"offset" msgpack:"offset"`
	Limit  uint32    `json:"limit" yaml:"limit" msgpack:"limit"`
}

func (o *FollowStoreFetchFollowersArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "userId":
			o.UserID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		case "offset":
			o.Offset, err = decoder.ReadUint32()
		case "limit":
			o.Limit, err = decoder.ReadUint32()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *FollowStoreFetchFollowersArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(3)
	encoder.WriteString("userId")
	encoder.WriteString(o.UserID.String())
	encoder.WriteString("offset")
	encoder.WriteUint32(o.Offset)
	encoder.WriteString("limit")
	encoder.WriteUint32(o.Limit)

	return nil
}

type FollowStoreFetchFollowsArgs struct {
	UserID uuid.UUID `json:"userId" yaml:"userId" msgpack:"userId"`
	Offset uint32    `json:"offset" yaml:"offset" msgpack:"offset"`
	Limit  uint32    `json:"limit" yaml:"limit" msgpack:"limit"`
}

func (o *FollowStoreFetchFollowsArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "userId":
			o.UserID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		case "offset":
			o.Offset, err = decoder.ReadUint32()
		case "limit":
			o.Limit, err = decoder.ReadUint32()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *FollowStoreFetchFollowsArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(3)
	encoder.WriteString("userId")
	encoder.WriteString(o.UserID.String())
	encoder.WriteString("offset")
	encoder.WriteUint32(o.Offset)
	encoder.WriteString("limit")
	encoder.WriteUint32(o.Limit)

	return nil
}

func (o *FollowRef) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "id":
			o.ID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		case "time":
			o.Time, err = decoder.ReadTime()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *FollowRef) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("id")
	encoder.WriteString(o.ID.String())
	encoder.WriteString("time")
	encoder.WriteTime(o.Time)

	return nil
}

func (o *UserRef) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "id":
			o.ID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		case "followers":
			o.Followers, err = decoder.ReadUint32()
		case "follows":
			o.Follows, err = decoder.ReadUint32()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *UserRef) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(3)
	encoder.WriteString("id")
	encoder.WriteString(o.ID.String())
	encoder.WriteString("followers")
	encoder.WriteUint32(o.Followers)
	encoder.WriteString("follows")
	encoder.WriteUint32(o.Follows)

	return nil
}

func (o *Follow) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "followedId":
			o.FollowedID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		case "followerId":
			o.FollowerID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		case "time":
			o.Time, err = decoder.ReadTime()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Follow) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(3)
	encoder.WriteString("followedId")
	encoder.WriteString(o.FollowedID.String())
	encoder.WriteString("followerId")
	encoder.WriteString(o.FollowerID.String())
	encoder.WriteString("time")
	encoder.WriteTime(o.Time)

	return nil
}

var (
	gCaller invoke.Caller
)

func Initialize(caller invoke.Caller) {
	gCaller = caller
}

type FollowStoreImpl struct {
	opLoad           uint32
	opGetMultiple    uint32
	opIsFollowing    uint32
	opFollow         uint32
	opUnfollow       uint32
	opFetchFollowers uint32
	opFetchFollows   uint32
	opMyFollows      uint32
}

func NewFollowStore() *FollowStoreImpl {
	return &FollowStoreImpl{
		opLoad:           invoke.ImportRequestResponse("nanochat.io.follows.v1.FollowStore", "load"),
		opGetMultiple:    invoke.ImportRequestStream("nanochat.io.follows.v1.FollowStore", "getMultiple"),
		opIsFollowing:    invoke.ImportRequestResponse("nanochat.io.follows.v1.FollowStore", "isFollowing"),
		opFollow:         invoke.ImportRequestResponse("nanochat.io.follows.v1.FollowStore", "follow"),
		opUnfollow:       invoke.ImportRequestResponse("nanochat.io.follows.v1.FollowStore", "unfollow"),
		opFetchFollowers: invoke.ImportRequestStream("nanochat.io.follows.v1.FollowStore", "fetchFollowers"),
		opFetchFollows:   invoke.ImportRequestStream("nanochat.io.follows.v1.FollowStore", "fetchFollows"),
		opMyFollows:      invoke.ImportRequestStream("nanochat.io.follows.v1.FollowStore", "myFollows"),
	}
}

func (f *FollowStoreImpl) Load(ctx context.Context, userID uuid.UUID) mono.Mono[UserRef] {
	request := FollowStoreLoadArgs{
		UserID: userID,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[UserRef](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], f.opLoad)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.MsgPackDecode[UserRef])
}

func (f *FollowStoreImpl) GetMultiple(ctx context.Context, userIDs []uuid.UUID) flux.Flux[UserRef] {
	request := FollowStoreGetMultipleArgs{
		UserIDs: userIDs,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[UserRef](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], f.opGetMultiple)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestStream(ctx, pl)
	return flux.Map(future, transform.MsgPackDecode[UserRef])
}

func (f *FollowStoreImpl) IsFollowing(ctx context.Context, userID uuid.UUID) mono.Mono[bool] {
	request := FollowStoreIsFollowingArgs{
		UserID: userID,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[bool](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], f.opIsFollowing)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Bool.Decode)
}

func (f *FollowStoreImpl) Follow(ctx context.Context, followedID uuid.UUID) mono.Void {
	request := FollowStoreFollowArgs{
		FollowedID: followedID,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[struct{}](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], f.opFollow)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Void.Decode)
}

func (f *FollowStoreImpl) Unfollow(ctx context.Context, followedID uuid.UUID) mono.Void {
	request := FollowStoreUnfollowArgs{
		FollowedID: followedID,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[struct{}](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], f.opUnfollow)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Void.Decode)
}

func (f *FollowStoreImpl) FetchFollowers(ctx context.Context, userID uuid.UUID, offset uint32, limit uint32) flux.Flux[FollowRef] {
	request := FollowStoreFetchFollowersArgs{
		UserID: userID,
		Offset: offset,
		Limit:  limit,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[FollowRef](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], f.opFetchFollowers)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestStream(ctx, pl)
	return flux.Map(future, transform.MsgPackDecode[FollowRef])
}

func (f *FollowStoreImpl) FetchFollows(ctx context.Context, userID uuid.UUID, offset uint32, limit uint32) flux.Flux[FollowRef] {
	request := FollowStoreFetchFollowsArgs{
		UserID: userID,
		Offset: offset,
		Limit:  limit,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[FollowRef](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], f.opFetchFollows)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestStream(ctx, pl)
	return flux.Map(future, transform.MsgPackDecode[FollowRef])
}

func (f *FollowStoreImpl) MyFollows(ctx context.Context) flux.Flux[FollowRef] {
	payloadData := []byte{}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], f.opMyFollows)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestStream(ctx, pl)
	return flux.Map(future, transform.MsgPackDecode[FollowRef])
}
