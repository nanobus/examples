// Code generated by @apexlang/codegen. DO NOT EDIT.

package like

import (
	"context"
	"encoding/binary"
	"time"

	"github.com/google/uuid"
	"github.com/nanobus/iota/go/invoke"
	"github.com/nanobus/iota/go/msgpack"
	"github.com/nanobus/iota/go/msgpack/convert"
	"github.com/nanobus/iota/go/payload"
	"github.com/nanobus/iota/go/proxy"
	"github.com/nanobus/iota/go/rx/flux"
	"github.com/nanobus/iota/go/rx/mono"
	"github.com/nanobus/iota/go/transform"
)

type ns struct{}

func (n *ns) Namespace() string {
	return "nanochat.io.like.v1"
}

type LikeStore interface {
	Like(ctx context.Context, likableID uuid.UUID) mono.Void
	Unlike(ctx context.Context, likableID uuid.UUID) mono.Void
	Load(ctx context.Context, likableID uuid.UUID) mono.Mono[Likable]
	Delete(ctx context.Context, likableID uuid.UUID) mono.Mono[Likable]
	GetMultiple(ctx context.Context, likableIDs []uuid.UUID) flux.Flux[Likable]
	GetLikedBy(ctx context.Context, likableID uuid.UUID, offset uint32, limit uint32) flux.Flux[LikeRef]
}

type LikeRef struct {
	ns
	// The likers's user ID
	UserID uuid.UUID `json:"userId" yaml:"userId" msgpack:"userId"`
	// Creation timestamp (for sorting)
	Time time.Time `json:"time" yaml:"time" msgpack:"time"`
}

func (l *LikeRef) Type() string {
	return "LikeRef"
}

type Likable struct {
	ns
	// Identifer of the likable entity.
	ID uuid.UUID `json:"id" yaml:"id" msgpack:"id"`
	// The number of likes.
	Likes uint32 `json:"likes" yaml:"likes" msgpack:"likes"`
}

func (l *Likable) Type() string {
	return "Likable"
}

// Like record
type Like struct {
	ns
	// The tweet ID liked
	LikableID uuid.UUID `json:"likableId" yaml:"likableId" msgpack:"likableId"`
	// The likers's user ID
	UserID uuid.UUID `json:"userId" yaml:"userId" msgpack:"userId"`
	// Creation timestamp (for sorting)
	Time time.Time `json:"time" yaml:"time" msgpack:"time"`
}

func (l *Like) Type() string {
	return "Like"
}

type LikeStoreLikeArgs struct {
	LikableID uuid.UUID `json:"likableId" yaml:"likableId" msgpack:"likableId"`
}

func (o *LikeStoreLikeArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "likableId":
			o.LikableID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *LikeStoreLikeArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("likableId")
	encoder.WriteString(o.LikableID.String())

	return nil
}

type LikeStoreUnlikeArgs struct {
	LikableID uuid.UUID `json:"likableId" yaml:"likableId" msgpack:"likableId"`
}

func (o *LikeStoreUnlikeArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "likableId":
			o.LikableID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *LikeStoreUnlikeArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("likableId")
	encoder.WriteString(o.LikableID.String())

	return nil
}

type LikeStoreLoadArgs struct {
	LikableID uuid.UUID `json:"likableId" yaml:"likableId" msgpack:"likableId"`
}

func (o *LikeStoreLoadArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "likableId":
			o.LikableID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *LikeStoreLoadArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("likableId")
	encoder.WriteString(o.LikableID.String())

	return nil
}

type LikeStoreDeleteArgs struct {
	LikableID uuid.UUID `json:"likableId" yaml:"likableId" msgpack:"likableId"`
}

func (o *LikeStoreDeleteArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "likableId":
			o.LikableID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *LikeStoreDeleteArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("likableId")
	encoder.WriteString(o.LikableID.String())

	return nil
}

type LikeStoreGetMultipleArgs struct {
	LikableIDs []uuid.UUID `json:"likableIds" yaml:"likableIds" msgpack:"likableIds"`
}

func (o *LikeStoreGetMultipleArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "likableIds":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.LikableIDs = make([]uuid.UUID, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem uuid.UUID
				nonNilItem, err = convert.Parse(uuid.Parse)(decoder.ReadString())
				if err != nil {
					return err
				}
				o.LikableIDs = append(o.LikableIDs, nonNilItem)
			}
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *LikeStoreGetMultipleArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("likableIds")
	encoder.WriteArraySize(uint32(len(o.LikableIDs)))
	for _, v := range o.LikableIDs {
		encoder.WriteString(v.String())
	}

	return nil
}

type LikeStoreGetLikedByArgs struct {
	LikableID uuid.UUID `json:"likableId" yaml:"likableId" msgpack:"likableId"`
	Offset    uint32    `json:"offset" yaml:"offset" msgpack:"offset"`
	Limit     uint32    `json:"limit" yaml:"limit" msgpack:"limit"`
}

func (o *LikeStoreGetLikedByArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "likableId":
			o.LikableID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		case "offset":
			o.Offset, err = decoder.ReadUint32()
		case "limit":
			o.Limit, err = decoder.ReadUint32()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *LikeStoreGetLikedByArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(3)
	encoder.WriteString("likableId")
	encoder.WriteString(o.LikableID.String())
	encoder.WriteString("offset")
	encoder.WriteUint32(o.Offset)
	encoder.WriteString("limit")
	encoder.WriteUint32(o.Limit)

	return nil
}

func (o *LikeRef) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "userId":
			o.UserID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		case "time":
			o.Time, err = decoder.ReadTime()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *LikeRef) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("userId")
	encoder.WriteString(o.UserID.String())
	encoder.WriteString("time")
	encoder.WriteTime(o.Time)

	return nil
}

func (o *Likable) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "id":
			o.ID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		case "likes":
			o.Likes, err = decoder.ReadUint32()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Likable) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("id")
	encoder.WriteString(o.ID.String())
	encoder.WriteString("likes")
	encoder.WriteUint32(o.Likes)

	return nil
}

func (o *Like) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "likableId":
			o.LikableID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		case "userId":
			o.UserID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		case "time":
			o.Time, err = decoder.ReadTime()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Like) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(3)
	encoder.WriteString("likableId")
	encoder.WriteString(o.LikableID.String())
	encoder.WriteString("userId")
	encoder.WriteString(o.UserID.String())
	encoder.WriteString("time")
	encoder.WriteTime(o.Time)

	return nil
}

var (
	gCaller invoke.Caller
)

func Initialize(caller invoke.Caller) {
	gCaller = caller
}

type LikeStoreImpl struct {
	opLike        uint32
	opUnlike      uint32
	opLoad        uint32
	opDelete      uint32
	opGetMultiple uint32
	opGetLikedBy  uint32
}

func NewLikeStore() *LikeStoreImpl {
	return &LikeStoreImpl{
		opLike:        invoke.ImportRequestResponse("nanochat.io.like.v1.LikeStore", "like"),
		opUnlike:      invoke.ImportRequestResponse("nanochat.io.like.v1.LikeStore", "unlike"),
		opLoad:        invoke.ImportRequestResponse("nanochat.io.like.v1.LikeStore", "load"),
		opDelete:      invoke.ImportRequestResponse("nanochat.io.like.v1.LikeStore", "delete"),
		opGetMultiple: invoke.ImportRequestStream("nanochat.io.like.v1.LikeStore", "getMultiple"),
		opGetLikedBy:  invoke.ImportRequestStream("nanochat.io.like.v1.LikeStore", "getLikedBy"),
	}
}

func (l *LikeStoreImpl) Like(ctx context.Context, likableID uuid.UUID) mono.Void {
	request := LikeStoreLikeArgs{
		LikableID: likableID,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[struct{}](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], l.opLike)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Void.Decode)
}

func (l *LikeStoreImpl) Unlike(ctx context.Context, likableID uuid.UUID) mono.Void {
	request := LikeStoreUnlikeArgs{
		LikableID: likableID,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[struct{}](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], l.opUnlike)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Void.Decode)
}

func (l *LikeStoreImpl) Load(ctx context.Context, likableID uuid.UUID) mono.Mono[Likable] {
	request := LikeStoreLoadArgs{
		LikableID: likableID,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[Likable](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], l.opLoad)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.MsgPackDecode[Likable])
}

func (l *LikeStoreImpl) Delete(ctx context.Context, likableID uuid.UUID) mono.Mono[Likable] {
	request := LikeStoreDeleteArgs{
		LikableID: likableID,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[Likable](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], l.opDelete)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.MsgPackDecode[Likable])
}

func (l *LikeStoreImpl) GetMultiple(ctx context.Context, likableIDs []uuid.UUID) flux.Flux[Likable] {
	request := LikeStoreGetMultipleArgs{
		LikableIDs: likableIDs,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[Likable](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], l.opGetMultiple)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestStream(ctx, pl)
	return flux.Map(future, transform.MsgPackDecode[Likable])
}

func (l *LikeStoreImpl) GetLikedBy(ctx context.Context, likableID uuid.UUID, offset uint32, limit uint32) flux.Flux[LikeRef] {
	request := LikeStoreGetLikedByArgs{
		LikableID: likableID,
		Offset:    offset,
		Limit:     limit,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[LikeRef](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], l.opGetLikedBy)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestStream(ctx, pl)
	return flux.Map(future, transform.MsgPackDecode[LikeRef])
}
