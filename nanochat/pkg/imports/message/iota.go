// Code generated by @apexlang/codegen. DO NOT EDIT.

package message

import (
	"context"
	"encoding/binary"
	"time"

	"github.com/google/uuid"
	"github.com/nanobus/iota/go/invoke"
	"github.com/nanobus/iota/go/msgpack"
	"github.com/nanobus/iota/go/msgpack/convert"
	"github.com/nanobus/iota/go/payload"
	"github.com/nanobus/iota/go/proxy"
	"github.com/nanobus/iota/go/rx/flux"
	"github.com/nanobus/iota/go/rx/mono"
	"github.com/nanobus/iota/go/transform"
)

type ns struct{}

func (n *ns) Namespace() string {
	return "nanochat.io.message.v1"
}

type MessageStore interface {
	Store(ctx context.Context, message string) mono.Mono[Message]
	Load(ctx context.Context, id uuid.UUID) mono.Mono[Message]
	Delete(ctx context.Context, id uuid.UUID) mono.Mono[Message]
	MyMessages(ctx context.Context, before *time.Time, limit uint32) flux.Flux[Message]
	GetFeed(ctx context.Context, userIDs []uuid.UUID, before *time.Time, limit uint32) flux.Flux[Message]
	GetUserMessages(ctx context.Context, userID uuid.UUID, before *time.Time, limit uint32) flux.Flux[Message]
}

// Message record.
type Message struct {
	ns
	// The dynamically generated Tweet ID.
	ID uuid.UUID `json:"id" yaml:"id" msgpack:"id"`
	// The tweet owner.
	UserID uuid.UUID `json:"userId" yaml:"userId" msgpack:"userId"`
	// The message body.
	Message string `json:"message" yaml:"message" msgpack:"message"`
	// The time the tweet was entered.
	Time time.Time `json:"time" yaml:"time" msgpack:"time"`
}

func (m *Message) Type() string {
	return "Message"
}

type MessageStoreStoreArgs struct {
	Message string `json:"message" yaml:"message" msgpack:"message"`
}

func (o *MessageStoreStoreArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "message":
			o.Message, err = decoder.ReadString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MessageStoreStoreArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("message")
	encoder.WriteString(o.Message)

	return nil
}

type MessageStoreLoadArgs struct {
	ID uuid.UUID `json:"id" yaml:"id" msgpack:"id"`
}

func (o *MessageStoreLoadArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "id":
			o.ID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MessageStoreLoadArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("id")
	encoder.WriteString(o.ID.String())

	return nil
}

type MessageStoreDeleteArgs struct {
	ID uuid.UUID `json:"id" yaml:"id" msgpack:"id"`
}

func (o *MessageStoreDeleteArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "id":
			o.ID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MessageStoreDeleteArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("id")
	encoder.WriteString(o.ID.String())

	return nil
}

type MessageStoreMyMessagesArgs struct {
	Before *time.Time `json:"before,omitempty" yaml:"before,omitempty" msgpack:"before,omitempty"`
	Limit  uint32     `json:"limit" yaml:"limit" msgpack:"limit"`
}

func (o *MessageStoreMyMessagesArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "before":
			o.Before, err = decoder.ReadNillableTime()
		case "limit":
			o.Limit, err = decoder.ReadUint32()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MessageStoreMyMessagesArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("before")
	encoder.WriteNillableTime(o.Before)
	encoder.WriteString("limit")
	encoder.WriteUint32(o.Limit)

	return nil
}

type MessageStoreGetFeedArgs struct {
	UserIDs []uuid.UUID `json:"userIds" yaml:"userIds" msgpack:"userIds"`
	Before  *time.Time  `json:"before,omitempty" yaml:"before,omitempty" msgpack:"before,omitempty"`
	Limit   uint32      `json:"limit" yaml:"limit" msgpack:"limit"`
}

func (o *MessageStoreGetFeedArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "userIds":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.UserIDs = make([]uuid.UUID, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem uuid.UUID
				nonNilItem, err = convert.Parse(uuid.Parse)(decoder.ReadString())
				if err != nil {
					return err
				}
				o.UserIDs = append(o.UserIDs, nonNilItem)
			}
		case "before":
			o.Before, err = decoder.ReadNillableTime()
		case "limit":
			o.Limit, err = decoder.ReadUint32()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MessageStoreGetFeedArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(3)
	encoder.WriteString("userIds")
	encoder.WriteArraySize(uint32(len(o.UserIDs)))
	for _, v := range o.UserIDs {
		encoder.WriteString(v.String())
	}
	encoder.WriteString("before")
	encoder.WriteNillableTime(o.Before)
	encoder.WriteString("limit")
	encoder.WriteUint32(o.Limit)

	return nil
}

type MessageStoreGetUserMessagesArgs struct {
	UserID uuid.UUID  `json:"userId" yaml:"userId" msgpack:"userId"`
	Before *time.Time `json:"before,omitempty" yaml:"before,omitempty" msgpack:"before,omitempty"`
	Limit  uint32     `json:"limit" yaml:"limit" msgpack:"limit"`
}

func (o *MessageStoreGetUserMessagesArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "userId":
			o.UserID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		case "before":
			o.Before, err = decoder.ReadNillableTime()
		case "limit":
			o.Limit, err = decoder.ReadUint32()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MessageStoreGetUserMessagesArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(3)
	encoder.WriteString("userId")
	encoder.WriteString(o.UserID.String())
	encoder.WriteString("before")
	encoder.WriteNillableTime(o.Before)
	encoder.WriteString("limit")
	encoder.WriteUint32(o.Limit)

	return nil
}

func (o *Message) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "id":
			o.ID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		case "userId":
			o.UserID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		case "message":
			o.Message, err = decoder.ReadString()
		case "time":
			o.Time, err = decoder.ReadTime()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Message) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(4)
	encoder.WriteString("id")
	encoder.WriteString(o.ID.String())
	encoder.WriteString("userId")
	encoder.WriteString(o.UserID.String())
	encoder.WriteString("message")
	encoder.WriteString(o.Message)
	encoder.WriteString("time")
	encoder.WriteTime(o.Time)

	return nil
}

var (
	gCaller invoke.Caller
)

func Initialize(caller invoke.Caller) {
	gCaller = caller
}

type MessageStoreImpl struct {
	opStore           uint32
	opLoad            uint32
	opDelete          uint32
	opMyMessages      uint32
	opGetFeed         uint32
	opGetUserMessages uint32
}

func NewMessageStore() *MessageStoreImpl {
	return &MessageStoreImpl{
		opStore:           invoke.ImportRequestResponse("nanochat.io.message.v1.MessageStore", "store"),
		opLoad:            invoke.ImportRequestResponse("nanochat.io.message.v1.MessageStore", "load"),
		opDelete:          invoke.ImportRequestResponse("nanochat.io.message.v1.MessageStore", "delete"),
		opMyMessages:      invoke.ImportRequestStream("nanochat.io.message.v1.MessageStore", "myMessages"),
		opGetFeed:         invoke.ImportRequestStream("nanochat.io.message.v1.MessageStore", "getFeed"),
		opGetUserMessages: invoke.ImportRequestStream("nanochat.io.message.v1.MessageStore", "getUserMessages"),
	}
}

func (m *MessageStoreImpl) Store(ctx context.Context, message string) mono.Mono[Message] {
	request := MessageStoreStoreArgs{
		Message: message,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[Message](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.opStore)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.MsgPackDecode[Message])
}

func (m *MessageStoreImpl) Load(ctx context.Context, id uuid.UUID) mono.Mono[Message] {
	request := MessageStoreLoadArgs{
		ID: id,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[Message](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.opLoad)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.MsgPackDecode[Message])
}

func (m *MessageStoreImpl) Delete(ctx context.Context, id uuid.UUID) mono.Mono[Message] {
	request := MessageStoreDeleteArgs{
		ID: id,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[Message](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.opDelete)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.MsgPackDecode[Message])
}

func (m *MessageStoreImpl) MyMessages(ctx context.Context, before *time.Time, limit uint32) flux.Flux[Message] {
	request := MessageStoreMyMessagesArgs{
		Before: before,
		Limit:  limit,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[Message](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.opMyMessages)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestStream(ctx, pl)
	return flux.Map(future, transform.MsgPackDecode[Message])
}

func (m *MessageStoreImpl) GetFeed(ctx context.Context, userIDs []uuid.UUID, before *time.Time, limit uint32) flux.Flux[Message] {
	request := MessageStoreGetFeedArgs{
		UserIDs: userIDs,
		Before:  before,
		Limit:   limit,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[Message](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.opGetFeed)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestStream(ctx, pl)
	return flux.Map(future, transform.MsgPackDecode[Message])
}

func (m *MessageStoreImpl) GetUserMessages(ctx context.Context, userID uuid.UUID, before *time.Time, limit uint32) flux.Flux[Message] {
	request := MessageStoreGetUserMessagesArgs{
		UserID: userID,
		Before: before,
		Limit:  limit,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[Message](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.opGetUserMessages)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestStream(ctx, pl)
	return flux.Map(future, transform.MsgPackDecode[Message])
}
