// Code generated by @apexlang/codegen. DO NOT EDIT.

package message

import (
	"context"
	"encoding/binary"
	"time"

	"github.com/google/uuid"
	"github.com/nanobus/iota/go/invoke"
	"github.com/nanobus/iota/go/msgpack"
	"github.com/nanobus/iota/go/payload"
	"github.com/nanobus/iota/go/proxy"
	"github.com/nanobus/iota/go/rx/flux"
	"github.com/nanobus/iota/go/rx/mono"
	"github.com/nanobus/iota/go/transform"
)

var (
	gCaller invoke.Caller
)

func Initialize(caller invoke.Caller) {
	gCaller = caller
}

type MessageStoreImpl struct {
	opStore           uint32
	opLoad            uint32
	opDelete          uint32
	opMyMessages      uint32
	opGetFeed         uint32
	opGetUserMessages uint32
}

func NewMessageStore() *MessageStoreImpl {
	return &MessageStoreImpl{
		opStore:           invoke.ImportRequestResponse("nanochat.io.messsage.v1.MessageStore", "store"),
		opLoad:            invoke.ImportRequestResponse("nanochat.io.messsage.v1.MessageStore", "load"),
		opDelete:          invoke.ImportRequestResponse("nanochat.io.messsage.v1.MessageStore", "delete"),
		opMyMessages:      invoke.ImportRequestStream("nanochat.io.messsage.v1.MessageStore", "myMessages"),
		opGetFeed:         invoke.ImportRequestStream("nanochat.io.messsage.v1.MessageStore", "getFeed"),
		opGetUserMessages: invoke.ImportRequestStream("nanochat.io.messsage.v1.MessageStore", "getUserMessages"),
	}
}

func (m *MessageStoreImpl) Store(ctx context.Context, message string) mono.Mono[Message] {
	request := MessageStoreStoreArgs{
		Message: message,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[Message](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.opStore)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.MsgPackDecode[Message])
}

func (m *MessageStoreImpl) Load(ctx context.Context, id uuid.UUID) mono.Mono[Message] {
	request := MessageStoreLoadArgs{
		ID: id,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[Message](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.opLoad)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.MsgPackDecode[Message])
}

func (m *MessageStoreImpl) Delete(ctx context.Context, id uuid.UUID) mono.Mono[Message] {
	request := MessageStoreDeleteArgs{
		ID: id,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[Message](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.opDelete)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.MsgPackDecode[Message])
}

func (m *MessageStoreImpl) MyMessages(ctx context.Context, before *time.Time, limit uint32) flux.Flux[Message] {
	request := MessageStoreMyMessagesArgs{
		Before: before,
		Limit:  limit,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[Message](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.opMyMessages)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestStream(ctx, pl)
	return flux.Map(future, transform.MsgPackDecode[Message])
}

func (m *MessageStoreImpl) GetFeed(ctx context.Context, userIds []uuid.UUID, before *time.Time, limit uint32) flux.Flux[Message] {
	request := MessageStoreGetFeedArgs{
		UserIds: userIds,
		Before:  before,
		Limit:   limit,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[Message](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.opGetFeed)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestStream(ctx, pl)
	return flux.Map(future, transform.MsgPackDecode[Message])
}

func (m *MessageStoreImpl) GetUserMessages(ctx context.Context, userID uuid.UUID, before *time.Time, limit uint32) flux.Flux[Message] {
	request := MessageStoreGetUserMessagesArgs{
		UserID: userID,
		Before: before,
		Limit:  limit,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[Message](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.opGetUserMessages)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestStream(ctx, pl)
	return flux.Map(future, transform.MsgPackDecode[Message])
}
