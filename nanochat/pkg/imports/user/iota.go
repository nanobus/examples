// Code generated by @apexlang/codegen. DO NOT EDIT.

package user

import (
	"context"
	"encoding/binary"

	"github.com/google/uuid"
	"github.com/nanobus/iota/go/invoke"
	"github.com/nanobus/iota/go/msgpack"
	"github.com/nanobus/iota/go/msgpack/convert"
	"github.com/nanobus/iota/go/payload"
	"github.com/nanobus/iota/go/proxy"
	"github.com/nanobus/iota/go/rx/flux"
	"github.com/nanobus/iota/go/rx/mono"
	"github.com/nanobus/iota/go/transform"
)

type ns struct{}

func (n *ns) Namespace() string {
	return "nanochat.io.user.v1"
}

type UserStore interface {
	Me(ctx context.Context) mono.Mono[User]
	Load(ctx context.Context, userID uuid.UUID) mono.Mono[User]
	GetMultiple(ctx context.Context, userIDs []uuid.UUID) flux.Flux[User]
	FindByHandle(ctx context.Context, handle string) mono.Mono[User]
	GetFive(ctx context.Context) flux.Flux[User]
}

// User record
type User struct {
	ns
	// User ID.
	ID uuid.UUID `json:"id" yaml:"id" msgpack:"id"`
	// Handle.
	Handle string `json:"handle" yaml:"handle" msgpack:"handle"`
}

func (u *User) Type() string {
	return "User"
}

type UserStoreLoadArgs struct {
	UserID uuid.UUID `json:"userId" yaml:"userId" msgpack:"userId"`
}

func (o *UserStoreLoadArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "userId":
			o.UserID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *UserStoreLoadArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("userId")
	encoder.WriteString(o.UserID.String())

	return nil
}

type UserStoreGetMultipleArgs struct {
	UserIDs []uuid.UUID `json:"userIds" yaml:"userIds" msgpack:"userIds"`
}

func (o *UserStoreGetMultipleArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "userIds":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.UserIDs = make([]uuid.UUID, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem uuid.UUID
				nonNilItem, err = convert.Parse(uuid.Parse)(decoder.ReadString())
				if err != nil {
					return err
				}
				o.UserIDs = append(o.UserIDs, nonNilItem)
			}
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *UserStoreGetMultipleArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("userIds")
	encoder.WriteArraySize(uint32(len(o.UserIDs)))
	for _, v := range o.UserIDs {
		encoder.WriteString(v.String())
	}

	return nil
}

type UserStoreFindByHandleArgs struct {
	Handle string `json:"handle" yaml:"handle" msgpack:"handle"`
}

func (o *UserStoreFindByHandleArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "handle":
			o.Handle, err = decoder.ReadString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *UserStoreFindByHandleArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("handle")
	encoder.WriteString(o.Handle)

	return nil
}

func (o *User) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "id":
			o.ID, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		case "handle":
			o.Handle, err = decoder.ReadString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *User) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("id")
	encoder.WriteString(o.ID.String())
	encoder.WriteString("handle")
	encoder.WriteString(o.Handle)

	return nil
}

var (
	gCaller invoke.Caller
)

func Initialize(caller invoke.Caller) {
	gCaller = caller
}

type UserStoreImpl struct {
	opMe           uint32
	opLoad         uint32
	opGetMultiple  uint32
	opFindByHandle uint32
	opGetFive      uint32
}

func NewUserStore() *UserStoreImpl {
	return &UserStoreImpl{
		opMe:           invoke.ImportRequestResponse("nanochat.io.user.v1.UserStore", "me"),
		opLoad:         invoke.ImportRequestResponse("nanochat.io.user.v1.UserStore", "load"),
		opGetMultiple:  invoke.ImportRequestStream("nanochat.io.user.v1.UserStore", "getMultiple"),
		opFindByHandle: invoke.ImportRequestResponse("nanochat.io.user.v1.UserStore", "findByHandle"),
		opGetFive:      invoke.ImportRequestStream("nanochat.io.user.v1.UserStore", "getFive"),
	}
}

func (u *UserStoreImpl) Me(ctx context.Context) mono.Mono[User] {
	payloadData := []byte{}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], u.opMe)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.MsgPackDecode[User])
}

func (u *UserStoreImpl) Load(ctx context.Context, userID uuid.UUID) mono.Mono[User] {
	request := UserStoreLoadArgs{
		UserID: userID,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[User](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], u.opLoad)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.MsgPackDecode[User])
}

func (u *UserStoreImpl) GetMultiple(ctx context.Context, userIDs []uuid.UUID) flux.Flux[User] {
	request := UserStoreGetMultipleArgs{
		UserIDs: userIDs,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[User](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], u.opGetMultiple)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestStream(ctx, pl)
	return flux.Map(future, transform.MsgPackDecode[User])
}

func (u *UserStoreImpl) FindByHandle(ctx context.Context, handle string) mono.Mono[User] {
	request := UserStoreFindByHandleArgs{
		Handle: handle,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[User](err)
	}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], u.opFindByHandle)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.MsgPackDecode[User])
}

func (u *UserStoreImpl) GetFive(ctx context.Context) flux.Flux[User] {
	payloadData := []byte{}
	var metadata [8]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], u.opGetFive)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := gCaller.RequestStream(ctx, pl)
	return flux.Map(future, transform.MsgPackDecode[User])
}
